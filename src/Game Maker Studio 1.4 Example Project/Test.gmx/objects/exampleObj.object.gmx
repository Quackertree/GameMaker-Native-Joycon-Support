<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Connect to joycons
/*
    Note that these joycons ALREADY HAVE TO BE PAIRED with the Windows machine!
    
    You can do this by using any of the already existing tutorials online. Or simply search "Bluetooth" on your machine, open the settings, press 'Add Device' and pair the two.
    Be aware that, when you shut down your computer, you'll have to resync the joycons. The same goes when attaching them to your Switch (as they resync with the Switch).
    
    If connection was succesful, the lights will stop blinking on your Joycon.
    If the connection failed, the function will return false and nothing will happen. All other functions have safety built in in case the Joycon isn't connected (or drops connection).
*/

joycon_connect(JoyconDevice.LEFT);
joycon_connect(JoyconDevice.RIGHT);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Example setup
/*
    This is not very interesting. It's just a demonstration setup.
    
    I didn't use objects for the cursors to make the example as lightweight as possible.
    Please don't do this approach yourself.
    Purely use this code to understand the functions added by this extension.
*/

joyLeftX = room_width / 2 - 128;
joyLeftY = room_height / 2;
joyLeftRot = 0;
joyLeftHue = 0;
joyLeftScale = 1;
joyLeftLight = 1;

joyRightX = room_width / 2 + 128;
joyRightY = room_height / 2 + 128;
joyRightRot = 0;
joyRightHue = 0;
joyRightScale = 1;
joyRightLight = 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Example step
/*
    The code for the example to make the cursors move.
    
    See Create event for disclaimer.
*/

//Analog stick
/*
    Note that the analog sticks don't move at exactly the same speed. This is a calibration issue, though this shouldn't be any problem for simple, fun experimenting.
    Dead center is automatically taken into account by the joycon_get_analog function (if unwanted, use *_raw).
    
    The Y-axis is already inverted to account for GM's inverted axis! :)
*/

joyLeftX += joycon_get_analog(JoyconDevice.LEFT, JoyconAxis.HORIZONTAL) * 3;
joyLeftY += joycon_get_analog(JoyconDevice.LEFT, JoyconAxis.VERTICAL) * 3;

joyRightX += joycon_get_analog(JoyconDevice.RIGHT, JoyconAxis.HORIZONTAL) * 3;
joyRightY += joycon_get_analog(JoyconDevice.RIGHT, JoyconAxis.VERTICAL) * 3;

//Scaling
/*
    Button functions support both check, pressed and released.
    It is highly recommended to import the enum script to make your life easier
*/

joyLeftScale += (joycon_check_button(JoyconDevice.LEFT, JoyconButton.BTN_DOWN) - joycon_check_button(JoyconDevice.LEFT, JoyconButton.BTN_UP)) / 10.0;
joyRightScale += (joycon_check_button(JoyconDevice.RIGHT, JoyconButton.BTN_B) - joycon_check_button(JoyconDevice.RIGHT, JoyconButton.BTN_A)) / 10.0;

//Set LED
/*
    The LEDs are controlled by a bitflag. This means you can turn on multiple LEDs at once.
        1 = LED 1
        2 = LED 2
        4 = LED 3
        8 = LED 4
        
    So e.g. 3 would turn on LED 1 + LED 2.
    
    DO NOT CALL THE joycon_set_light(...) FUNCTION REPEATEDLY!
    THIS WILL OVERFLOW THE DATA STACK ON YOUR JOYCON!
*/

var v;

v = (joycon_check_button_pressed(JoyconDevice.LEFT, JoyconButton.BTN_SR) - joycon_check_button_pressed(JoyconDevice.LEFT, JoyconButton.BTN_SL));
if(abs(v) != 0)
{
    joyLeftLight += v;
    joycon_set_light(JoyconDevice.LEFT, abs(joyLeftLight % 16));
}

v = (joycon_check_button_pressed(JoyconDevice.RIGHT, JoyconButton.BTN_SR) - joycon_check_button_pressed(JoyconDevice.RIGHT, JoyconButton.BTN_SL));
if(abs(v) != 0)
{
    joyRightLight += v;
    joycon_set_light(JoyconDevice.RIGHT, abs(joyRightLight % 16));
}

//Shake for colour
/*
    Simply using the acceleration {x, y, z} data to create a vector from which the length is determined
    We check for a big value in acceleration to ensure the user is moving the Joycon rapidly (thus "shaking")
    
    Note that acceleration data is affected by gravity (read up on accelerometers to understand this better). 
    Although the function attempts to filter this (for unfiltered, use *_raw), rotating the Joycon will always return an unwanted acceleration value!
*/
var acclVecL = sqrt(sqr(joycon_get_accl_x(JoyconDevice.LEFT)) + sqr(joycon_get_accl_y(JoyconDevice.LEFT)) + sqr(joycon_get_accl_z(JoyconDevice.LEFT)));
if(acclVecL &gt; 5)
    joyLeftHue += acclVecL;
    
var acclVecR = sqrt(sqr(joycon_get_accl_x(JoyconDevice.RIGHT)) + sqr(joycon_get_accl_y(JoyconDevice.RIGHT)) + sqr(joycon_get_accl_z(JoyconDevice.RIGHT)));
if(acclVecR &gt; 5)
    joyRightHue += acclVecR;
    
//Rotation
/*
    Rotation comes relative rather than absolute!
    Because of this, a tiny rotation is neglected automatically (to prevent drifting).
*/
joyLeftRot += joycon_get_rot_z(JoyconDevice.LEFT);
joyRightRot += joycon_get_rot_z(JoyconDevice.RIGHT);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw GUI text

draw_set_colour(c_black);
draw_text(0, 0, "Move the analog stick on the Joycons to move the sprites.#Shake (or move) the Joycon to change colour.#Roll the Joycon to rotate the sprite.#Press A or Up to enlarge.#Press B or Down to shrink.#Use the shoulder buttons (SL/SR) to cycle the light on the Joycon.");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw example

var _origMat = matrix_get(matrix_world);
var _mat = matrix_build(joyLeftX, joyLeftY, 0, 0, 0, joyLeftRot, joyLeftScale, joyLeftScale, 1);
matrix_set(matrix_world, _mat);

draw_set_colour(make_colour_hsv(joyLeftHue, 255, 255));
draw_rectangle(-16, -16, 16, 16, false);

var _mat = matrix_build(joyRightX, joyRightY, 0, 0, 0, joyRightRot, joyRightScale, joyRightScale, 1);
matrix_set(matrix_world, _mat);

draw_set_colour(make_colour_hsv(joyRightHue, 255, 255));
draw_rectangle(-16, -16, 16, 16, false);

matrix_set(matrix_world, _origMat);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
